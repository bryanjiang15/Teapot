"""
Effect Interpreter - Processes trigger effects and returns events
"""

from typing import Dict, Any, List, Optional
from TeapotEngine.ruleset.IR import RulesetIR
from TeapotEngine.ruleset.rule_definitions.EffectDefinition import EffectDefinition
from TeapotEngine.ruleset.ExpressionModel import EvalContext, Predicate
from TeapotEngine.ruleset.system_models.SystemEvent import *
from .GameState import GameState
from .Events import Event
from .Component import Component


class EffectInterpreter:
    """Processes trigger effects and converts them to events"""
    
    def __init__(self, ruleset: RulesetIR):
        """Initialize the effect interpreter with a ruleset"""
        self.ruleset = ruleset
    
    def process_effects(
        self,
        effects: List[EffectDefinition],
        game_state: GameState,
        caused_by: Optional[Dict[str, str]] = None,
        source_component: Optional[Component] = None,
        event: Optional[Event] = None
    ) -> List[Event]:
        """
        Process a list of effects and return the events they generate.
        
        Args:
            effects: List of EffectDefinition objects to process
            game_state: Current game state
            caused_by: Dictionary with "object_type" and "object_id" indicating what caused this effect
            source_component: The component that triggered this effect
            event: The event that triggered this effect (if any)
            
        Returns:
            List of Event objects generated by processing the effects
        """
        all_events = []
        
        for effect in effects:
            events = self._process_effect(
                effect,
                game_state,
                caused_by,
                source_component,
                event
            )
            all_events.extend(events)
        
        return all_events
    
    def _process_effect(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]],
        source_component: Optional[Component],
        event: Optional[Event]
    ) -> List[Event]:
        """Process a single effect based on its kind"""
        
        # Create evaluation context for condition/predicate evaluation
        ctx = self._create_eval_context(
            game_state,
            source_component,
            event,
            caused_by
        )
        
        if effect.kind == "execute_rule":
            return self._process_execute_rule(effect, game_state, caused_by)
        
        elif effect.kind == "emit_event":
            return self._process_emit_event(effect, caused_by)
        
        elif effect.kind == "sequence":
            return self._process_sequence(effect, game_state, caused_by, source_component, event)
        
        elif effect.kind == "if":
            return self._process_if(effect, game_state, caused_by, source_component, event, ctx)
        
        elif effect.kind == "for_each":
            return self._process_for_each(effect, game_state, caused_by, source_component, event, ctx)
        
        elif effect.kind == "modify_state":
            return self._process_modify_state(effect, game_state, caused_by)
        
        else:
            # Unknown effect kind - log warning and return empty list
            return []
    
    def _process_execute_rule(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]]
    ) -> List[Event]:
        """Process an execute_rule effect"""
        if effect.rule_id is None:
            return []
        
        # Get the rule from the ruleset
        rule = self.ruleset.get_rule(effect.rule_id)
        if not rule:
            return []
        
        events = []
        
        # Process rule's effects (legacy dict-based effects)
        for rule_effect in rule.effects:
            if isinstance(rule_effect, dict):
                op = rule_effect.get("op")
                
                if op == "execute_rule":
                    # Recursively execute another rule
                    nested_rule_id = rule_effect.get("rule_id")
                    if nested_rule_id:
                        nested_rule = self.ruleset.get_rule(nested_rule_id)
                        if nested_rule:
                            for nested_effect_dict in nested_rule.effects:
                                nested_events = self._process_legacy_effect(
                                    nested_effect_dict, game_state, caused_by
                                )
                                events.extend(nested_events)
                
                else:
                    # Process legacy effect
                    nested_events = self._process_legacy_effect(
                        rule_effect, game_state, caused_by
                    )
                    events.extend(nested_events)
        
        # Emit RuleExecuted event
        events.append(Event(
            type=RULE_EXECUTED,
            payload={
                "rule_id": effect.rule_id,
                "caused_by": caused_by,
                "rule_params": effect.rule_params
            },
            caused_by=caused_by.get("object_id") if caused_by else None
        ))
        
        return events
    
    def _process_emit_event(
        self,
        effect: EffectDefinition,
        caused_by: Optional[Dict[str, str]]
    ) -> List[Event]:
        """Process an emit_event effect"""
        if effect.event_type is None:
            return []
        
        return [Event(
            type=effect.event_type,
            payload=effect.event_payload.copy(),
            caused_by=caused_by.get("object_id") if caused_by else None
        )]
    
    def _process_sequence(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]],
        source_component: Optional[Component],
        event: Optional[Event]
    ) -> List[Event]:
        """Process a sequence effect - execute actions in order"""
        all_events = []
        
        for action in effect.actions:
            action_events = self._process_effect(
                action,
                game_state,
                caused_by,
                source_component,
                event
            )
            all_events.extend(action_events)
        
        return all_events
    
    def _process_if(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]],
        source_component: Optional[Component],
        event: Optional[Event],
        ctx: EvalContext
    ) -> List[Event]:
        """Process an if effect - conditional execution"""
        if effect.condition is None:
            # No condition means always execute then_actions
            return self.process_effects(
                effect.then_actions,
                game_state,
                caused_by,
                source_component,
                event
            )
        
        # Evaluate condition
        condition_met = effect.condition.evaluate(ctx)
        
        if condition_met:
            return self.process_effects(
                effect.then_actions,
                game_state,
                caused_by,
                source_component,
                event
            )
        else:
            return self.process_effects(
                effect.else_actions,
                game_state,
                caused_by,
                source_component,
                event
            )
    
    def _process_for_each(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]],
        source_component: Optional[Component],
        event: Optional[Event],
        ctx: EvalContext
    ) -> List[Event]:
        """Process a for_each effect - loop over filtered targets"""
        if effect.target_filter is None:
            # No filter means no targets to iterate over
            return []
        
        # Evaluate filter to get matching components
        # Note: target_filter is a Predicate, but for_each typically needs a Selector
        # This is a limitation in the current EffectDefinition model
        # For now, we'll assume target_filter can be evaluated in context
        # and return components that match
        
        # TODO: This needs to be enhanced when Selector support is added to EffectDefinition
        # For now, return empty list as this requires Selector evaluation
        return []
    
    def _process_modify_state(
        self,
        effect: EffectDefinition,
        game_state: GameState,
        caused_by: Optional[Dict[str, str]]
    ) -> List[Event]:
        """Process a modify_state effect - direct state changes"""
        if effect.state_op is None:
            return []
        
        # Convert state operations to events
        # This allows state changes to be tracked in the event log
        
        if effect.state_op == "set_phase":
            phase_id = effect.state_args.get("phase_id")
            if phase_id:
                return [Event(
                    type=PHASE_STARTED,
                    payload={"phase_id": phase_id},
                    caused_by=caused_by.get("object_id") if caused_by else None
                )]
        
        elif effect.state_op == "add_resource":
            # This should emit a RESOURCE_CHANGED event
            return [Event(
                type=RESOURCE_CHANGED,
                payload={
                    "player_id": effect.state_args.get("player_id"),
                    "resource": effect.state_args.get("resource"),
                    "amount": effect.state_args.get("amount", 1)
                },
                caused_by=caused_by.get("object_id") if caused_by else None
            )]
        
        # Add more state operations as needed
        
        return []
    
    def _process_legacy_effect(
        self,
        effect_dict: Dict[str, Any],
        game_state: GameState,
        caused_by: Optional[Dict[str, str]]
    ) -> List[Event]:
        """Process legacy dict-based effects for backward compatibility"""
        op = effect_dict.get("op")
        events = []
        
        if op == "move_card":
            events.append(Event(
                type=CARD_MOVED,
                payload={
                    "card_id": effect_dict.get("card_id", "top_card"),
                    "from_zone": effect_dict.get("from_zone", "deck"),
                    "to_zone": effect_dict.get("to_zone", "hand"),
                    "player_id": (
                        game_state.get_player(effect_dict.get("player_id", "self"), caused_by).id
                        if game_state.get_player(effect_dict.get("player_id", "self"), caused_by)
                        else None
                    )
                },
                caused_by=caused_by.get("object_id") if caused_by else None
            ))
        
        elif op == "gain_resource":
            player = game_state.get_player(effect_dict.get("player_id", "self"), caused_by)
            if player:
                events.append(Event(
                    type=RESOURCE_CHANGED,
                    payload={
                        "player_id": player.id,
                        "resource": effect_dict.get("resource", "mana"),
                        "amount": effect_dict.get("amount", 1)
                    },
                    caused_by=caused_by.get("object_id") if caused_by else None
                ))
        
        elif op == "deal_damage":
            events.append(Event(
                type=DAMAGE_DEALT,
                payload={
                    "target": effect_dict.get("target"),
                    "amount": effect_dict.get("amount", 1),
                    "source": effect_dict.get("source")
                },
                caused_by=caused_by.get("object_id") if caused_by else None
            ))
        
        return events
    
    def _create_eval_context(
        self,
        game_state: GameState,
        source_component: Optional[Component],
        event: Optional[Event],
        caused_by: Optional[Dict[str, str]]
    ) -> EvalContext:
        """Create an evaluation context for predicate/selector evaluation"""
        # Default to game component if no source component provided
        if source_component is None:
            source_component = game_state.get_game_component_instance()
        
        # If still None, create a minimal component context
        # This shouldn't happen in normal operation
        if source_component is None:
            # Fallback: try to get a player component
            # This is a workaround - ideally we should always have a source
            from TeapotEngine.ruleset.ComponentDefinition import ComponentType
            players = game_state.get_components_by_type(ComponentType.PLAYER)
            if players:
                source_component = players[0]
            else:
                # Last resort: create a dummy context
                # This will cause evaluation errors, but prevents crashes
                raise ValueError("Cannot create EvalContext: no source component available")
        
        # Convert event to dict if provided
        event_dict = None
        if event:
            event_dict = event.to_dict() if hasattr(event, 'to_dict') else {
                "type": event.type,
                "payload": event.payload,
                "caused_by": event.caused_by
            }
        
        return EvalContext(
            source=source_component,
            event=event_dict,
            targets=(),  # Targets would be set by selector evaluation
            game=game_state,
            phase=str(game_state.current_phase),
            turn=game_state.turn_number
        )

